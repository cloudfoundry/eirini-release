
# GKE with certificates generated by LetsEncrypt

- [GKE with certificates generated by LetsEncrypt](#gke-with-certificates-generated-by-letsencrypt)
  - [Prerequisites](#prerequisites)
  - [Set up GCP environment](#set-up-gcp-environment)
    - [Using Terraform](#using-terraform)
    - [Manual steps](#manual-steps)
      - [Reserve static IP address](#reserve-static-ip-address)
      - [Configure DNS](#configure-dns)
      - [Create service account with right access](#create-service-account-with-right-access)
  - [Deployment](#deployment)
    - [Initialize Helm](#initialize-helm)
    - [Deploy NGINX ingress controller & cert manager](#deploy-nginx-ingress-controller--cert-manager)
    - [Create a certificate issuer](#create-a-certificate-issuer)
    - [Create certificates](#create-certificates)
    - [Values.yaml](#valuesyaml)
    - [Deploying UAA](#deploying-uaa)
      - [Get UAA certificates](#get-uaa-certificates)
      - [Deploy UAA](#deploy-uaa)
    - [Deploying SCF](#deploying-scf)
      - [Get CA certificate](#get-ca-certificate)
      - [Get certificates for Gorouter](#get-certificates-for-gorouter)
      - [Deploy SCF](#deploy-scf)
  - [Certificate rotation](#certificate-rotation)

## Prerequisites

Make the Eirini helm repository available to helm:

```bash
helm repo add eirini https://cloudfoundry-incubator.github.io/eirini-release
```

Make the Bits helm repository available to helm:

```bash
helm repo add bits https://cloudfoundry-incubator.github.io/bits-service-release/helm
```

## Set up GCP environment

We recommend using [Terraform](https://www.terraform.io/) for this part because it makes the whole process much simpler. If you don't want to use Terraform, we have instructions [here](#manual-steps) how to do it manually.

### Using Terraform

Save [this](https://raw.githubusercontent.com/cloudfoundry-incubator/eirini-ci/master/gke-cluster/terraform.tf) tf file in a directory of your choice.
Go to that directory and initialize Terraform.

Then run the following command

```bash
terraform apply -var 'name=<your-environment-name>' \
    -var 'project-id=<gcp-project-id>' \
    -var 'region=<location-for-regional-resources>' \
    -var 'zone=<cluster-node-zone>' \
    -var 'node-count-per-zone=<number-of-nodes-per-zone>' \
    -var 'dns-zone-name=<existing-dns-zone-name>' \
    -var 'dns-name=<dns-name>'
```

_Note: The zone must be in the specified region._

After the command completes, you'll have a file named `sa-private-key.json` in the same directory. This is your service account private key in JSON format, base64 encoded. This is only populated when creating a new key. If you lose it, you won't be able to recover it!


### Manual steps

#### Reserve static IP address

See [more](https://cloud.google.com/compute/docs/ip-addresses/reserve-static-external-ip-address)

*Note*: After you create the static ip you may notice that it is not connected to
any backend. This is expected. Later on when we install the nginx ingress
controller it will automatically create a backend and attach the static ip to
it.

#### Configure DNS

Create a DNS zone in GKE and add the following A records:

- `<environment>.<zone>: <static-ip-address>`
- `*.<environment>.<zone>: <static-ip-address>`
- `uaa.<environment>.<zone>: <static-ip-address>`
- `*.uaa.<environment>.<zone>: <static-ip-address>`

*Note*: It is easier to reuse an existing DNS zone if you happen to have one
configured. If you create a new zone you need to configure your domain to
use the google cloud nameservers that your zone is mapped to. These are listed
as an NS record in your cloud DNS zone. If you do not do this your domain will
not resolve to the static ip in the google cloud but will rather use the default
nameservers of your domain provider.

#### Create service account with right access

In order to generate valid certificate your components need to be able to create TXT DNS records in your zone.
Create a gcloud Role with the following permissions:

```text
  dns.changes.create
  dns.changes.get
  dns.managedZones.list
  dns.resourceRecordSets.create
  dns.resourceRecordSets.delete
  dns.resourceRecordSets.list
  dns.resourceRecordSets.update
```

Create a gcloud service-account, attaching it to the Role that you created.

## Deployment

Before proceding, make sure the KUBECONFIG environment variable points to your new cluster.
You can get it by running the following command:
```bash
gcloud container clusters get-credentials <environment-name> \
    --zone <zone-name> \
    --project <gcp-project-id>
```

### Initialize Helm

Install the tiller component on the cluster.

```bash
helm init --service-account <service-account-name> \
    --upgrade \
    --wait
```
[This](https://raw.githubusercontent.com/cloudfoundry-incubator/eirini-ci/master/k8s-specs/tiller-service-account.yml) is an example service-account that can be used. Note that it is granted the cluster admin role.

### Deploy NGINX ingress controller & cert manager

Deploy [Nginx ingress controller](https://hub.helm.sh/charts/stable/nginx-ingress) with the following properties:

```bash
helm install stable/nginx-ingress \
    --set rbac.create=true \
    --set controller.service.loadBalancerIP="$(terraform output static_ip)"
```

Deploy [CertManager](https://hub.helm.sh/charts/jetstack/cert-manager).
The documentation below is valid only for cert-manager v0.11.

```
kubectl apply -f https://raw.githubusercontent.com/jetstack/cert-manager/release-0.11/deploy/manifests/00-crds.yaml --validate=false 
helm repo add jetstack https://charts.jetstack.io
helm install --namespace cert-manager jetstack/cert-manager --version v0.11.0
```

### Create a certificate issuer

Create a secret with service account key in cert-manager namespace:

```bash
DNS_SERVICE_ACCOUNT="$(cat sa-private-key.json | base64 -D)"
kubectl create secret generic <secret-name> \
    -n cert-manager \
    --from-literal=service-account.json="$DNS_SERVICE_ACCOUNT"
```

This is required for DNS validation. See more
[in official documentation](https://docs.cert-manager.io/en/latest/tutorials/acme/dns-validation.html).

Now create the cluster issuer with `dns01` solver. Read more about it [in official documentation](https://docs.cert-manager.io/en/latest/tasks/issuers/index.html). [Here is an example](https://raw.githubusercontent.com/cloudfoundry-incubator/eirini-ci/master/cert-manager/letsencrypt-dns-issuer.yaml) from our CI.

_Note: The secret name in the `.spec.solvers.dns01.clouddns.serviceAccountSecretRef.name` of the ClusterIssuer resource **must** be the same as the name of the secret that constains the service account information._

## Values.yaml

```yaml
bits:
  env:
    DOMAIN: <environment>.<zone>
  ingress:
    endpoint: <environment>.<zone>
    use: true
    annotations:
      cert-manager.io/cluster-issuer: "<lets-encrypt-issuer-name>"
      # use the following line instead if you are using regular issuer
      # cert-manager.io/issuer: "<lets-encrypt-issuer-name>"
  secrets:
    BITS_SERVICE_SECRET: $BITS_SECRET
    BITS_SERVICE_SIGNING_USER_PASSWORD: $BITS_SECRET
    BLOBSTORE_PASSWORD: $BITS_SECRET

  # use cert generated by cert manager
  useExistingSecret: true

env:
    DOMAIN: <environment>.<zone>

    UAA_HOST: uaa.<environment>.<zone>
    UAA_PORT: 443
    UAA_PUBLIC_PORT: 443

kube:
    storage_class:
      persistent: standard
      shared: standard
    auth: rbac

secrets:
    CLUSTER_ADMIN_PASSWORD: $CLUSTER_ADMIN_PASSWORD
    UAA_ADMIN_CLIENT_SECRET: $UAA_ADMIN_CLIENT_SECRET
    BLOBSTORE_PASSWORD: $BITS_SECRET

ingress:
  enabled: true
  annotations:
    "nginx.ingress.kubernetes.io/proxy-body-size": "100m"
    cert-manager.io/cluster-issuer: "<lets-encrypt-issuer-name>"
    # use the following line instead if you are using regular issuer
    # cert-manager.io/issuer: "<lets-encrypt-issuer-name>"

eirini:
  opi:
    use_registry_ingress: true
    ingress_endpoint: <environment>.<zone>

  secrets:
    BLOBSTORE_PASSWORD: $BITS_SECRET
```

## Deploying UAA

```bash
  helm upgrade --install uaa \
    eirini/uaa \
    --namespace uaa \
    --values your-values.yaml
```

## Deploying SCF

### Get CA certificate

Some components validate the CA certificate for the UAA endpoint. You can get LetsEncrypt CA certificate for UAA running the following command:

```bash
    ROOT_CA="$(curl -s https://letsencrypt.org/certs/isrgrootx1.pem.txt)"
    INTERMEDIATE_CA="$(curl -s https://letsencrypt.org/certs/letsencryptauthorityx3.pem.txt)"
    CA_CERT="${ROOT_CA}

${INTERMEDIATE_CA}"
```

For more information about LetsEncrypt chain of trust see [here](https://letsencrypt.org/certificates/).

### Deploy SCF

```bash
  helm upgrade --install scf \
    eirini/cf \
    --namespace scf \
    --values your-values.yaml \
    --set "secrets.UAA_CA_CERT=${CA_CERT}"
```

## Certificate rotation

Bits certificate is rotated automatically by cert-manager and is picked up by Nginx Ingress controller.
Cert-manager will rotate certificates in Kubrenetes secrets, but you will have to copy them to the SCF secrets.
You can do this by upgrading UAA and SCF periodically.

